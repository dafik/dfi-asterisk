"use strict";
const AsteriskManager = require('../internal/asteriskManager'),

    dAmiLib = require("../../examples/dfi-asterisk-ami/src/dAmi"),
    actions = dAmiLib.Actions,

    AsteriskServerEvents = require('../events/def/asteriskServerEvents'),

    AgentsCollection = require('../collections/agents'),
    AsteriskAgent = require('../models/asteriskAgent'),
    AgentState = require('../enums/agentState'),
    AgentStates = AgentState.prototype.States,

    QueueManagerEvents = require('./queueManager').Events;


/**
 * Manages all events related to agents on Asterisk server. For correct work
 * ensure enabled AgentCalledEvents. You have to set
 * <code>eventwhencalled = yes</code> in <code>queues.conf</code>.
 */
class AgentManager extends AsteriskManager {
    constructor(options, state) {
        super(options, state);

        this.agents = new AgentsCollection();
        this.ringingAgents = new Map();


        this.server.once(AsteriskServerEvents.BeforeInitialized, function () {
            if (this.server.isMangerEnabled('queue')) {
                let queueManager = this.server.getManager('queue');
                queueManager.on(QueueManagerEvents.memberAdd, this._handleQueueAddMember, this);
                queueManager.on(QueueManagerEvents.memberRemove, this._handleQueueRemoveMember, this);
            }
        }, this)


    }

    /**
     * Retrieves all agents registered at Asterisk server by sending an AgentsAction.
     * @param {function} [callback]
     * @param {*} [thisp] callback this
     */
    start(callback, thisp) {


        function finish() {
            if (typeof callback == "function") {
                this.server.loggers.logger.info('manager "AgentManager" started');
                callback.call(thisp, null, 'agentManager');
            }
        }

        /**
         *
         * @param {ManagerError} err
         * @param {ManagerResponse} re
         */
        function onResponse(err, re) {
            if (err) {
                callback.call(thisp, err);
                return;
            }
            if (typeof re != "undefined") {
                re.getEvents().forEach(onEachEvent, this)
            }
            finish.call(this);
        }

        function onEachEvent(event) {
            if (event.event == 'agents') {
                handleAgentsEvent.call(this, event);
            }
        }

        /**
         * On AgentsEvent create a new Agent.
         *
         * @param {AgentsEvent} event generated by Asterisk server.
         */
        function handleAgentsEvent(event) {
            this._getOrCreateAgent(null, event);
        }

        this.server.loggers.logger.info('starting manager "AgentManager"');

        if (!this.enabled) {
            finish.call(this);
            return
        }


        var map = {
            //channelState
            //destChannelState
            'agentcalled': this._handleAgentCalledEvent,
            //channelState
            //destChannelState
            'agentconnect': this._handleAgentConnectEvent,
            //channelState
            //destChannelState
            'agentcomplete': this._handleAgentCompleteEvent,
            'agentcallbacklogin': this._handleAgentCallbackLoginEvent,
            'agentcallbacklogoff': this._handleAgentCallbackLogoffEvent,
            //channelState
            //destChannelState
            'agentlogin': this._handleAgentLoginEvent,
            'agentlogoff': this._handleAgentLogoffEvent,
            //'channelState',
            // 'destChannel',
            'agentdump': function (event) {
                var x = 1;
            },
            //'channelState', //'destChannel',
            'agentringnoanswer': function (event) {
                //delete ringing ?
                var x = 1;
            }
        };
        this._mapEvents(map);

        /**
         * @type {AgentsAction}
         */
        var action;
        action = new actions.Agents();
        this.server.sendEventGeneratingAction(action, onResponse, this);

    }

    disconnected() {
        this.agents.clear();
    }


    /**
     * Return or create (dynamic) the requested agent.
     *
     * @param {string}  agentId identifier for agent
     * @return {AsteriskAgent} the requested agent
     */
    _getOrCreateAgent(agentId, event) {

        var agent = this.agents.get(agentId);

        if (!agent) {
            if (!event) {
                var x = 1;
            }
            var options = {
                name: event.interface,
                id: event.interface,
                device: this.server.managers.device.devices.get(event.interface),
                peer: this.server.managers.peer.peers.get(event.interface),
                state: AgentState.byName('agent_unknown')

            }
            agent = new AsteriskAgent(options, this.server);
            this._addAgent(agent);
        }

        return agent;
    }

    /**
     * Update state if agent was called.
     *
     * @param {AgentCalledEvent} event
     */
    _handleAgentCalledEvent(event) {
        this.logger.debug("handle  AgentCalled agent %j", event.interface);

        /**
         * @type {AsteriskAgent}
         */
        var agent = this._getOrCreateAgent(event.interface, event);
        if (agent == null) {
            this.logger.error("Ignored AgentCalledEvent for unknown agent %j", event.interface);
            return;
        }
        this._updateRingingAgents(event.channel, agent);
        this._updateAgentState(agent, AgentStates.AGENT_RINGING);
    }


    /**
     * Update state if agent was connected to channel.
     *
     * @param {AgentConnectEvent}  event
     */
    _handleAgentConnectEvent(event) {
        this.logger.debug("handle  AgentConnect agent %j", event.interface);

        var agent = this._getOrCreateAgent(event.interface, event);
        if (agent == null) {
            this.logger.error("Ignored AgentConnectEvent for unknown agent %j", event.interface, event.channel);
            return;
        }
        this._updateAgentState(agent, AgentStates.AGENT_ONCALL, event.channel);
    }

    /**
     * Change state if agent logs in.
     * @param {AgentLoginEvent} event
     */
    _handleAgentLoginEvent(event) {
        this.logger.debug("handle  AgentLogin agent %j", event.interface);

        var agent = this._getOrCreateAgent(event.interface, event);
        if (agent == null) {
            this.logger.error("Ignored AgentLoginEvent for unknown agent " + event.get('agent') + ". Agents: " + this.agents.keys().toString());
            return;
        }
        this._updateAgentState(agent, AgentStates.AGENT_IDLE);
    }

    /**
     * Change state if agent logs out.
     * @param {AgentLogoffEvent} event
     */
    _handleAgentLogoffEvent(event) {
        this.logger.debug("handle  AgentLogoff agent %j", event.interface);

        var agent = this._getOrCreateAgent(event.interface, event);
        if (agent == null) {
            this.logger.error("Ignored AgentLogoffEvent for unknown agent " + event.get('agent') + ". Agents: " + this.agents.keys().toString());
            return;
        }
        this._updateAgentState(agent, AgentStates.AGENT_LOGGEDOFF);
    }

    /**
     * Change state if agent logs in.
     *
     * @param {AgentCallbackLoginEvent} event
     */
    _handleAgentCallbackLoginEvent(event) {
        this.logger.debug("handle  AgentCallbackLogin agent %j", event.interface);

        var agent = this._getOrCreateAgent(event.interface, event);
        if (agent == null) {

            this.logger.error("Ignored AgentCallbackLoginEvent for unknown agent " + event.get('agent') + ". Agents: " + this.agents.keys().toString());


            return;
        }
        this._updateAgentState(agent, AgentStates.AGENT_IDLE);
    }

    /**
     * Change state if agent logs out.
     *
     * @param {AgentCallbackLogoffEvent} event
     */
    _handleAgentCallbackLogoffEvent(event) {
        this.logger.debug("handle  AgentCallbackLogoff agent %j", event.interface);

        var agent = this._getOrCreateAgent(event.interface, event);
        if (agent == null) {
            this.logger.error("Ignored AgentCallbackLogoffEvent for unknown agent " + event.get('agent') + ". Agents: " + this.agents.keys().toString());
            return;
        }
        this._updateAgentState(agent, AgentStates.AGENT_LOGGEDOFF);
    }


    _handleAgentCompleteEvent(event) {
        this.logger.debug("handle  AgentComplete agent %j", event.interface);

        var agent = this._getOrCreateAgent(event.interface, event);
        if (agent == null) {
            this.logger.error("Ignored AgentCompleteEvent for unknown agent %j. Agents: %j", event.interface, this.getAgentsKeys());
            return;
        }
        //remove form ringings ?

        //agent.updateState(AgentStates.AGENT_LOGGEDOFF);
        this._updateAgentState(agent, AgentStates.AGENT_IDLE, event.channel);
    }


    /**
     *
     * @param {AsteriskQueueMember} member
     * @param {AsteriskQueue} queue
     */
    _handleQueueAddMember(member, queue) {
        this.logger.debug("handle  QueueAddMember agent %j", member.id);

        var agent = this.agents.get(member.id);
        if (!agent) {
            var options = {
                name: member.get('membername'),
                id: member.get('id'),
                device: this.server.managers.device.devices.get(member.id),
                state: AgentState.byName('agent_unknown')

            }
            agent = new AsteriskAgent(options, this.server);
            agent.addQueue(queue);

            member.set('agent', agent);
            this._addAgent(agent);
        }

    }

    /**
     *
     * @param {AsteriskQueueMember} member
     * @param {AsteriskQueue} queue
     */
    _handleQueueRemoveMember(member, queue) {
        this.logger.debug("handle  QueueRemoveMember agent %j", member.id);
        var agent = this.agents.get(member.id);
        if (!agent) {
            return
        }
        agent.removeQueue(queue);
    }

    /**
     * Add a new agent to the manager.
     *
     * @param {AsteriskAgent} agent agent to add.
     */
    _addAgent(agent) {
        this.logger.info('Adding new agent %j', agent.id);
        this.agents.add(agent);
    }


    getAgentsKeys() {
        return this.agents.pluck('id');
    }

    /**
     *  Set state of agent.
     * @param {AsteriskAgent} agent
     * @param {AgentState} newState
     * @private
     */
    _updateAgentState(agent, newState, channel) {
        if (typeof newState != 'object') {
            newState = AgentState.byName(newState);
        }
        if (this.ringingAgents.size > 0 && newState != AgentStates.AGENT_RINGING) {
            if (this.ringingAgents.has(channel)) {
                this.ringingAgents.delete(channel);
            }

        }

        this.logger.info("Set state of agent " + agent.get('id') + " to " + newState.name);

        agent.updateState(newState);
    }


    /**
     * Updates state of agent, if the call in a queue was redirect to the next
     * agent because the ringed agent doesn't answer the call. After reset
     * state, put the next agent in charge.
     *
     * @param {String} channelCalling
     * @param {AsteriskAgent} agent
     * @private
     */
    _updateRingingAgents(channelCalling, agent) {
        this.ringingAgents.set(channelCalling, agent);
    }

    /**
     * Return all agents registered at Asterisk server.
     *
     * @returns {AsteriskAgent[]} a collection of all agents.
     */
    getAgents() {
        /**
         * @type {AsteriskAgent[]}
         */
        var copy;
        copy = this.agents.toArray();
        return copy;
    }

    toJSON() {
        var obj = super.toJSON();
        obj.collection = this.agents.toJSON();


        return obj;
    }
}

module.exports = AgentManager;