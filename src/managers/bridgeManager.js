"use strict";
const
    Moment = require('moment'),
    _ = require('lodash'),



    dAmiLib = require("../../examples/dfi-asterisk-ami/src/dAmi"),
    actions = dAmiLib.Actions,
    events = dAmiLib.Events,

    AsteriskManager = require('../internal/asteriskManager'),
    AsteriskServerEvents = require('../events/def/asteriskServerEvents'),
    BridgesCollection = require('../collections/bridges'),
    AsteriskBridge = require('../models/asteriskBridge');


/**
 * Manages all events related to bridges on Asterisk server
 * @memberOf ast.managers

 * @typedef  BridgeManager
 * @property {AsteriskLogger} logger
 * @property {AsteriskServer} server
 * @property {BridgesCollection} bridges A Map of bridges by their bridgesId.
 * @property {ChannelManager} channelManager

 */
class BridgeManager extends AsteriskManager {
    /**
     * @param options
     * @param state
     */
    constructor(options, state) {
        super(options, state, new BridgesCollection());


        this.set('localMap', new Map());


        this.server.once(AsteriskServerEvents.BeforeInitialized, function () {
            this.channelManager = this.server.managers.channel
        }, this)
    }

    /**
     *
     * @returns {BridgesCollection}
     */
    get bridges() {
        return this.get('collection');
    }

    /**
     * @type Map.<string,AsteriskBridge>
     */
    get localMap() {
        return this.get('localMap');
    }


    /**
     * Retrieves all bridges registered at Asterisk server by sending an BridgesAction.
     * @param {function} [callback]
     * @param {*} [thisp] callback this
     */
    start(callback, thisp) {

        function finish() {
            if (typeof callback == "function") {
                this.server.loggers.logger.info('manager "BridgeManager" started');
                callback.call(thisp, null, 'BridgeManager');
            }
        }

        function onResponse(err, re) {
            if (err) {
                callback.call(thisp, err);
                return;
            }
            if (typeof re != "undefined") {
                re.getEvents().forEach(onEachEvent, this)
            }
            finish.call(this);
        }

        function onEachEvent(event) {
            if (event.event == 'bridgelistitem') {
                handleBridgesEvent.call(this, event);
            }
        }

        /**
         * On BridgesEvent create a new Bridge.
         *
         * @param {AsteriskEvent} event generated by Asterisk server.
         */
        function handleBridgesEvent(event) {
            /**
             * @type {AsteriskBridge}
             */
            var bridge = new AsteriskBridge(event, {server: this.server});
            this._addBridge(bridge);
        }


        this.server.loggers.logger.info('starting manager "BridgeManager"');

        if (!this.enabled) {
            finish.call(this);
            return
        }

        var map = {
            'bridgecreate': this._handleBridgeCreateEvent,
            'bridgedestroy': this._handleBridgeDestroyEvent,
            //channelState
            'bridgeenter': this._handleBridgeEnterEvent,
            //channelState
            'bridgeleave': this._handleBridgeLeaveEvent,
            'bridgemerge': this._handleBridgeMergeEvent,
            //localOneChannelState
            //localTwoChannelState
            'localbridge': this._handleLocalBridgeEvent,
            'hangup': this._handleHangupEvent //maybe listen to event ?
        };

        this._mapEvents(map);


        /**
         * @type {BridgeList}
         */
        var action;
        action = new actions.BridgeList();
        this.server.sendEventGeneratingAction(action, onResponse, this);


    }

    disconnected() {
        this.bridges.clear();
    }


    /**
     *
     * @param {AsteriskEvent} event
     */
    _handleBridgeCreateEvent(event) {
        this.logger.info('Handle BridgeCreateEvent %s', event.bridgeuniqueid);
        var bridge = new AsteriskBridge(event, {server: this.server});
        this._addBridge(bridge);
    }

    _handleBridgeDestroyEvent(event) {
        this.logger.info('Handle BridgeDestroyEvent %s', event.bridgeuniqueid);
        var bridge = this.bridges.get(event.bridgeuniqueid);
        if (bridge == null) {
            this.logger.error('Ignored BridgeEnterEvent for unknown bridge "' + event.bridgeuniqueid);
            return;
        }
        this.bridges.remove(event.bridgeuniqueid);
        bridge.destroy();
    }

    /**
     * @param {AsteriskEvent} event
     */
    _handleBridgeEnterEvent(event) {
        this.logger.info('Handle BridgeEnterEvent %s', event.bridgeuniqueid);
        var bridge = this.getBridgeByBridgeId(event.bridgeuniqueid);
        if (bridge == null) {
            this.logger.error('Ignored BridgeEnterEvent for unknown bridge "' + event.bridgeuniqueid);
            return;
        }
        if (this.server.managers.channel.enabled) {
            var channel = this.channelManager.getChannelById(event.uniqueid);
            if (channel == null) {
                this.logger.error('Ignored BridgeEnterEvent for unknown channel "' + event.channel);
                return;
            }
            channel.setBridge(bridge);
            bridge.get('channels').add(channel);
        }
    }

    /**
     * @param {AsteriskEvent} event
     */
    _handleBridgeLeaveEvent(event) {
        this.logger.info('Handle BridgeLeaveEvent %s', event.bridgeuniqueid);
        var bridge = this.getBridgeByBridgeId(event.bridgeuniqueid);
        if (bridge == null) {
            this.logger.error('Ignored BridgeLeaveEvent for unknown bridge "' + event.bridgeuniqueid);
            return;
        }    //1416479053.304
        if (this.server.managers.channel.enabled) {
            var channel = this.channelManager.getChannelById(event.uniqueid);
            if (channel == null) {
                this.logger.error('Ignored BridgeLeaveEvent for unknown channel "' + event.channel);
                return;
            }
            channel.removeBridge(bridge);
            if (!bridge.get('channels').has(channel.id)) {
                this.logger.error('Ignored BridgeLeaveEvent not having  channel "' + event.channel);
                return;
            }
            bridge.get('channels').remove(channel.id);
        }
    }

    _handleBridgeMergeEvent(event) {
        this.logger.info('Handle BridgeMergeEvent %s', event.bridgeuniqueid);

    }

    /**
     * @param {AsteriskEvent} event
     */
    _handleLocalBridgeEvent(event) {
        var id = event.localoneuniqueid + '-' + event.localtwouniqueid;
        this.logger.info('Handle LocalBridgeEvent %s, %s->%s', id, event.localonechannel, event.localtwochannel);


        if (this.bridges.has(id)) {
            return;
        }
        event.wasInBridgeManager = true;


        var attrs = {
            id: id,
            type: 'local',
            technology: 'local',
            numchannels: 2,
            creator: 'asterisk',
            name: id,
            isHangupFirst: false,
            isHangupSecond: false
        };

        attrs = _.extend(attrs, event);


        var bridge = new AsteriskBridge(attrs, {server: this.server});

        this._addLocalBridge(bridge);

        if (this.server.managers.channel.enabled) {
            /**
             * @type {AsteriskChannel}
             */
            var channel1 = this.channelManager.getChannelById(event.localoneuniqueid);
            var channel2 = this.channelManager.getChannelById(event.localtwouniqueid);

            this.logger.info('enter: "' + bridge.id + '" channel: "' + channel1.get('name') + '"');
            bridge.get('channels').add(channel1);
            this.logger.info('enter: "' + bridge.id + '" channel: "' + channel2.get('name') + '"');
            bridge.get('channels').add(channel2);

            channel1.channelLinked(event.dateReceived, channel2);
            channel2.channelLinked(event.dateReceived, channel1);

            channel1.setBridge(bridge);
            channel2.setBridge(bridge);
        }

    }

    /**
     * @param {AsteriskEvent} event
     */
    _handleHangupEvent(event) {
        this.logger.info('Handle HangupEvent %s', event.channel);

        let localMap = this.localMap;

        if (localMap.has(event.uniqueid)) {
            let bridge = localMap.get(event.uniqueid);
            if (bridge.get('localoneuniqueid') == event.uniqueid) {
                bridge.set('isHangupFirst', true);
            } else if (bridge.get('localtwouniqueid') == event.uniqueid) {
                bridge.set('isHangupSecond', true);
            } else {
                var x = 1;
            }
            if (bridge.get('isHangupFirst') && bridge.get('isHangupSecond')) {
                this.logger.info('remove local bridge: "' + bridge.id + '"');

                let localMap = this.localMap;
                localMap.delete(bridge.get('localoneuniqueid'));
                localMap.delete(bridge.get('localtwouniqueid'));

                this.bridges.remove(bridge)
            }
        }

        if (!this.server.managers.channel.enabled) {
            return;
        }
        /**
         * @type  HangupCause
         */
        var cause = null;

        /**
         *
         * @type {AsteriskChannel}
         */
        var channel = this.server.managers.channel.channels.get(event.uniqueid);

        if (channel == null) {
            channel = this.server.managers.channel.getChannelByName(event.channel);
            if (channel == null) {
                this.logger.error("Ignored HangupEvent for unknown channel " + event.uniqueid + '@' + Moment.unix(event.uniqueid).format() + ' - ' + event.channel);
                return;
            } else {
                var x = 1;
            }
        }
        // handle remove bridge for local bridge
        channel.get('bridges').forEach(onEachBridge, this);
        /**
         * @param {AsteriskBridge} bridge
         */
        function onEachBridge(bridge) {
            if (bridge.get('type') == 'local') {
                if (bridge.get('channels').has(channel.get('id'))) {
                    this.logger.info('leaving: "' + bridge.id + '" channel: "' + channel.get('name') + '"');
                    channel.removeBridge(bridge);
                    bridge.get('channels').remove(channel.get('id'));
                    if (bridge.get('channels').length == 0) {
                        this.logger.info('destroying: "' + bridge.id + '"');
                        this.bridges.remove(bridge.id);
                    }
                }
            }
        }
    }


    /**
     * Add a new bridge to the manager.
     *
     * @param {AsteriskBridge} bridge bridge to add.
     */
    _addBridge(bridge) {
        this.logger.info('adding bridge: "' + bridge.id + '"');

        this.bridges.add(bridge);
    }

    /**
     * Add a new bridge to the manager.
     *
     * @param {AsteriskBridge} bridge bridge to add.
     */
    _addLocalBridge(bridge) {
        this.logger.info('adding local bridge: "' + bridge.id + '"');

        let channel1 = bridge.get('localoneuniqueid');
        let channel2 = bridge.get('localtwouniqueid');

        let localMap = this.localMap;

        localMap.set(channel1, bridge);
        localMap.set(channel2, bridge);

        this.bridges.add(bridge);


    }


    /**
     * Return the requested bridge.
     *
     * @param {string}  bridgeId identifier for bridge
     * @return {AsteriskBridge} the requested bridge
     */

    getBridgeByBridgeId(bridgeId) {
        return this.bridges.get(bridgeId);
    }

    /**
     * Return all bridges;
     *
     * @returns {AsteriskBridge[]} a collection of all bridges.
     */
    getBridgesArray() {
        /**
         * @type {AsteriskBridge[]}
         */
        var copy;
        copy = this.bridges.toArray();
        return copy;
    }

    toJSON() {
        var obj = super.toJSON();
        obj.collection = this.bridges.toJSON();

        return obj;
    }

}
module.exports = BridgeManager;